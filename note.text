1. 【table 綁定監聽器】
    監聽click事件
    設計 onCellClicked() (事件觸發後，要執行的函式)
      下棋
      判斷是否遊戲結束 (勝利/平手 or 遊戲繼續)

2. 【畫OX】
    設計 draw()
      innerHTML + 新增class屬性

3. 【輪流畫OX】
    宣告 count回合數，判斷輪流畫OX

4. 【判斷連線】
    宣告 positions 玩家下棋位置array
       O玩家=[1, 4, 3, 2]
       X玩家=[, , ,]

    宣告 checkingLines 所有獲勝連線組合array
       [ [1, 2, 3], [4, 5, 6], [7, 8, 9], ...]
  
    設計 isPlayWin()，傳入positions 玩家下棋位置陣列，確認陣列內，是否有包含任一個連線組合
       迴圈一一比對 lines 內的獲勝連線
           若  positions 玩家陣列內， 包含獲勝連線的第一個位置 &&
               positions 玩家陣列內， 包含獲勝連線的第一個位置 &&
               positions 玩家陣列內， 包含獲勝連線的第一個位置 
             return true(獲勝)

       return false(遊戲繼續)

    修改 onCellClicked()
        將玩家下棋位置，推入 positions 陣列內

5. 【判斷是否還能下棋】
      設計 getEmptyPositions()
        宣告 allOccupiedPositions = positions內，所有玩家下棋的位置
        比對棋盤上所有位置[1, 2, 3, 4, 5, 6, 7, 8, 9]，使用filter，篩選出尚未被下的位置
        return 尚未被下的位置
  
6. 【判斷遊戲是否結束(勝利 or 平手 or 遊戲繼續)】
      設計 checkWinningCondition()，傳入玩家
        宣告 winningPlayer = isPlayerWin(玩家)
        若 winningPlayer 成立
          return alert(`${player} player won!`); (獲勝)

        若 getEmptyPositions().length === 0 成立
          return alert("Tied!"); (平手)
        
        以上都不成立 return false; (遊戲繼續)
        
7. 【遊戲推進：公布結果】
      修改 onCellClicked()
        某一方玩家下棋後，
          判斷遊戲是否結束：setTimeout + 呼叫checkWinningCondition()，傳入玩家

8. 【對手：改為電腦玩家】
      8-1. 【找出電腦的最佳下棋位置】
            priority 1 下這步 電腦贏
            priority 2 不下這步 電腦輸 (對手下這步就贏)
            priority 3 佔據最好位置 (中間位置)
            priority 4 鄰近位置
            priority 5 random

            設計 getMostValuablePosition()
              宣告 emptyPositions = getEmptyPositions() (還能下棋的位置陣列)
              宣告 defendPositions = [] (能夠防止玩家勝利的位置陣列)

              迴圈將 位置(假設電腦的下一步) 一一從 emptyPositions取出
                將 位置 推到 電腦的位置陣列 (拷貝Ｘ陣列)
                若 電腦獲勝 
                  return 位置

                將 位置 推到 玩家的位置陣列 (拷貝Ｏ陣列)
                若 玩家獲勝
                  將 位置 推到 defendPositions
              
              若 defendPositions 不是空的
                return 第一個 defendPositions
              
              若 中間位置 是空的
                return  中間位置

              以上都不成立 return 一個 random 位置 
      
      8-2. 【電腦下棋】
           設計 computerMove()
             下棋：draw(傳入：getMostValuablePosition(), 電腦玩家(X))
             判斷遊戲是否結束：checkWinningCondition(傳入：電腦玩家(X)) 
  
9. 【遊戲推進：控制流程】
    宣告變數 clickingThrottle = false (初始值，控制遊戲推進)

    修改 checkWinningCondition()
      修改(遊戲繼續) return false 改為 clickingThrottle = false 

    修改 computerMove()
      新增 clickingThrottle = true 
    
    修改 onCellClicked()
      新增 若 clickingThrottle = true {return} (若遊戲結束，棋盤無法點擊)

      if-else 條件式 改為 
      O玩家先下
      下棋位置 推入 O玩家位置陣列
      新增 clickingThrottle = true
      判斷遊戲是否結束 checkWinningCondition(O玩家)
      
      使用 setTimeout 執行 X電腦玩家後下
          若 遊戲未結束(clickingThrottle = false) 
             呼叫 computerMove()

10. 【重構與優化】
     最後一步下完棋，才判斷遊戲是否結束(平手)

       修改 onCellClicked()
         刪除 判斷遊戲是否結束 checkWinningCondition(O玩家)
        
         使用 setTimeout 執行 X電腦玩家後下
             新增 判斷遊戲是否結束 checkWinningCondition(O玩家)

             若 遊戲未結束(clickingThrottle = false) 
               呼叫 computerMove()


【虛擬碼】
   ※ 主流程 onClicked()
      下棋
          一個人下 draw(傳入：位置, 玩家(O或X))
          輪流下
      
      下棋位置 推入 O或X玩家位置陣列

      判斷遊戲是否結束 checkWinningCondition(傳入：玩家(O或X))
          贏 
            連線成功 isPlayerWin(傳入：玩家下的位置陣列) 
              return alert 贏
          平手
              沒位置下棋 getEmptyPositions()
                return alert 平手
          以上都不成立 return 遊戲繼續 
            

   ※ 下棋對手改為 => 電腦下 
       computerMove()
         
         下棋 draw(傳入：位置, 電腦玩家(X))
           判斷下哪最有價值位置 getMostValuePosition()
               priority 1 下這步 電腦贏
               priority 2 不下這步 電腦輸 (對手下這步就贏)
               priority 3 佔據最好位置 (中間位置)
               priority 4 鄰近位置
               priority 5 random
          
         下棋位置推入電腦玩家(X)位置陣列

         判斷遊戲是否結束 checkWinningCondition(電腦玩家(X))
    

   ※ 遊戲推進：控制流程 