1. 【table 綁定監聽器】
    監聽click事件
    handler(事件觸發後，要執行的函式): 設計onCellClicked()

2. 【畫OX】
    設計draw(): 宣告 count回合數，判斷輪流畫OX

3. 【判斷連線】
    宣告 positions 玩家下棋位置array
       O玩家=[1, 4, 3, 2]
       X玩家=[, , ,]

    宣告 checkingLines 所有獲勝連線組合array
       [ [1, 2, 3], [4, 5, 6], [7, 8, 9], ...]
  
    設計isPlayWin()，傳入positions 玩家下棋位置陣列，確認陣列內，是否有包含任一個連線組合
       迴圈一一比對 lines 內的獲勝連線
           若  positions 玩家陣列內， 包含獲勝連線的第一個位置 &&
               positions 玩家陣列內， 包含獲勝連線的第一個位置 &&
               positions 玩家陣列內， 包含獲勝連線的第一個位置 
             return true(獲勝)

       return false(遊戲繼續)

    修改onCellClicked()
        將玩家下棋位置，推入 positions 陣列內

  4. 【判斷平手】
      設計getEmptyPositions()
        宣告allOccupiedPositions = positions內，所有玩家下棋的位置
        比對棋盤上所有位置[1, 2, 3, 4, 5, 6, 7, 8, 9]，使用filter，篩選出尚未被下的位置
        回傳尚未被下的位置
  
  5. 【判斷遊戲是否結束(勝利 or 平手 or 遊戲繼續)】
      設計checkWinningCondition()，傳入玩家
        宣告 winningPlayer = isPlayerWin(玩家)
        若 winningPlayer 成立
          return alert(`${player} player won!`); (獲勝)

        若 getEmptyPositions().length === 0 成立
          return alert("Tied!"); (平手)
  
  6. 【遊戲推進：公布結果】
      修改onCellClicked()
        某一方玩家下棋後，
          判斷遊戲是否結束：setTimeout + 呼叫checkWinningCondition()，傳入玩家
  
  7. 【遊戲推進：控制流程】
      宣告變數 clickingThrottle = false (初始值，控制遊戲推進)
      
      修改onCellClicked()
        新增若 clickingThrottle = true {return} (棋盤無法點擊：判斷遊戲是否結束時、遊戲結束時)

        某一方玩家下棋後，
          新增 clickingThrottle = true
      
      修改checkWinningCondition()
        新增 clickingThrottle = false

  8. 【對手：改為電腦玩家】
      修改onCellClicked()
        if-else 條件判斷 改為 
          由 setTimeout 呼叫 checkWinningCondition()後，
          若 未達成勝利條件，直接自動由電腦下棋

  9. 【遊戲推進：控制流程】
      宣告 gameOverFlag = false 變數(初始值)，控制遊戲推進

      修改checkWinningCondition()
        若 某一方玩家勝利 成立
          新增 gameOverFlag = true
        
        若 平手 成立
          新增 gameOverFlag = true
